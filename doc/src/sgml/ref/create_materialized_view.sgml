<!--
doc/src/sgml/ref/create_materialized_view.sgml
PostgreSQL documentation
-->

<refentry id="sql-creatematerializedview">
 <indexterm zone="sql-creatematerializedview">
  <primary>CREATE MATERIALIZED VIEW</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE MATERIALIZED VIEW</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE MATERIALIZED VIEW</refname>
  <refpurpose>define a new materialized view</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
CREATE [ INCREMENTAL ] MATERIALIZED VIEW [ IF NOT EXISTS ] <replaceable>table_name</replaceable>
    [ (<replaceable>column_name</replaceable> [, ...] ) ]
    [ USING <replaceable class="parameter">method</replaceable> ]
    [ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) ]
    [ TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]
    AS <replaceable>query</replaceable>
    [ WITH [ NO ] DATA ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>CREATE MATERIALIZED VIEW</command> defines a materialized view of
   a query.  The query is executed and used to populate the view at the time
   the command is issued (unless <command>WITH NO DATA</command> is used) and may be
   refreshed later using <command>REFRESH MATERIALIZED VIEW</command>.
  </para>

  <para>
   <command>CREATE MATERIALIZED VIEW</command> is similar to
   <command>CREATE TABLE AS</command>, except that it also remembers the query used
   to initialize the view, so that it can be refreshed later upon demand.
   A materialized view has many of the same properties as a table, but there
   is no support for temporary materialized views.
  </para>
 </refsect1>

 <refsect1>
  <title>Parameters</title>

  <variablelist>
   <varlistentry>
    <term><literal>INCREMENTAL</literal></term>
    <listitem>
     <para>
      If specified, some triggers are automatically created so that the rows
      of the materialized view are immediately updated when base tables of the
      materialized view are updated. In general, this allows faster update of
      the materialized view at a price of slower update of the base tables
      because the triggers will be invoked. We call this form of materialized
      view as "Incrementally Maintainable Materialized View" (IMMV).
     </para>
     <para>
      There are restrictions of query definitions allowed to use this
      option. Followings are supported query definitions for IMMV:
      <itemizedlist>

       <listitem>
        <para>
         Inner joins (including self-joins).
        </para>
       </listitem>

       <listitem>
        <para>
         Outer joins with following restrictions:

         <itemizedlist>
          <listitem>
           <para>
            Outer join view's targetlist must contain attributes used in the
            join conditions.
            <programlisting>
CREATE INCREMENTAL MATERIALIZED VIEW mv AS SELECT a.i FROM mv_base_a a LEFT
JOIN mv_base_b b ON a.i=b.i;
ERROR:  targetlist must contain vars in the join condition for IVM with outer join
            </programlisting>
           </para>
          </listitem>

          <listitem>
           <para>
            Outer join view's targetlist cannot contain non strict functions.
            <programlisting>
CREATE INCREMENTAL MATERIALIZED VIEW mv AS SELECT a.i, b.i, (k > 10 OR k = -1)
FROM mv_base_a a LEFT JOIN mv_base_b b ON a.i=b.i;
ERROR:  targetlist cannot contain non strict functions for IVM with outer join
             </programlisting>
           </para>
          </listitem>

          <listitem>
           <para>
            Outer join supports only simple equijoin.
            <programlisting>
CREATE INCREMENTAL MATERIALIZED VIEW mv(a,b) AS SELECT a.i, b.i FROM mv_base_a
a LEFT JOIN mv_base_b b ON a.i>b.i;
ERROR:  Only simple equijoin is supported for IVM with outer join
CREATE INCREMENTAL MATERIALIZED VIEW mv(a,b,k,j) AS SELECT a.i, b.i, k j FROM
mv_base_a a LEFT JOIN mv_base_b b ON a.i=b.i AND k=j;
ERROR:  Only simple equijoin is supported for IVM with outer join
            </programlisting>
           </para>
           </listitem>

          <listitem>
           <para>
            Outer join view's WHERE clause cannot contain non null-rejecting
            predicates.
            <programlisting>
CREATE INCREMENTAL MATERIALIZED VIEW mv(a,b) AS SELECT a.i, b.i FROM mv_base_a
a LEFT JOIN mv_base_b b ON a.i=b.i WHERE k IS NULL;
ERROR:  WHERE cannot contain non null-rejecting predicates for IVM with outer join
CREATE INCREMENTAL MATERIALIZED VIEW mv(a,b) AS SELECT a.i, b.i FROM mv_base_a
a LEFT JOIN mv_base_b b ON a.i=b.i WHERE (k > 0 OR j > 0);
ERROR:  WHERE cannot contain non null-rejecting predicates for IVM with outer join
            </programlisting>
           </para>
          </listitem>

          <listitem>
           <para>
            Aggregate is not supported with outer join.
            <programlisting>
CREATE INCREMENTAL MATERIALIZED VIEW mv(a,b,v) AS SELECT a.i, b.i, sum(k) FROM
mv_base_a a LEFT JOIN mv_base_b b ON a.i=b.i GROUP BY a.i, b.i;
ERROR:  aggregate is not supported with IVM together with outer join
</programlisting>
           </para>
          </listitem>

          <listitem>
           <para>
            Subquery is not supported with outer join.
            <programlisting>
CREATE INCREMENTAL MATERIALIZED VIEW mv(a,b) AS SELECT a.i, b.i FROM mv_base_a
a LEFT JOIN (SELECT * FROM mv_base_b) b ON a.i=b.i;
ERROR:  subquery is not supported with IVM together with outer join
CREATE INCREMENTAL MATERIALIZED VIEW mv(a,b) AS SELECT a.i, b.i FROM mv_base_a
a LEFT JOIN mv_base_b b ON a.i=b.i WHERE EXISTS (SELECT 1 FROM mv_base_b b2
WHERE a.j = b.k);
ERROR:  subquery is not supported by IVM together with outer join
             </programlisting>
           </para>
          </listitem>
         </itemizedlist>
        </para>

       </listitem>

       <listitem>
        <para>
         Subqueries. However following forms are not supported.
        </para>

        <para>
         WHERE IN .. (subquery) is not supported:
         <programlisting>
CREATE INCREMENTAL MATERIALIZED VIEW mv_ivm03 AS SELECT i,j FROM
mv_base_a WHERE i IN (SELECT i FROM mv_base_b WHERE k &lt; 103 );
         </programlisting>
        </para>
        <para>
         subqueries in target list is not supported:
         <programlisting>
CREATE INCREMENTAL MATERIALIZED VIEW mv_ivm05 AS SELECT i,j, (SELECT k
FROM mv_base_b b WHERE a.i = b.i) FROM mv_base_a a;
         </programlisting>
        </para>
        <para>
         Nested EXISTS subqueries is not supported:
         <programlisting>
CREATE INCREMENTAL MATERIALIZED VIEW mv_ivm11 AS SELECT a.i,a.j FROM
mv_base_a a WHERE EXISTS(SELECT 1 FROM mv_base_b b WHERE EXISTS(SELECT
1 FROM mv_base_b c WHERE b.i = c.i));
         </programlisting>
        </para>
        <para>
         EXISTS subquery with aggregate function is not supported:
         <programlisting>
CREATE INCREMENTAL MATERIALIZED VIEW mv_ivm_exists AS SELECT COUNT(*)
FROM mv_base_a a WHERE EXISTS(SELECT 1 FROM mv_base_b b WHERE a.i =
b.i) OR a.i &gt; 5;
         </programlisting>
        </para>
        <para>
         EXISTS subquery with condition other than AND is not supported:
         <programlisting>
CREATE INCREMENTAL MATERIALIZED VIEW mv_ivm10 AS SELECT a.i,a.j FROM
mv_base_a a WHERE EXISTS(SELECT 1 FROM mv_base_b b WHERE a.i = b.i) OR
a.i &gt; 5;
         </programlisting>
        </para>
        </listitem>

       <listitem>
        <para>
         Some of aggregations (count, sum, avg, min, max) without HAVING
         clause.  However, aggregate functions in subquery is not supported:
         <programlisting>
CREATE INCREMENTAL MATERIALIZED VIEW mv_ivm09 AS SELECT a.i,a.j FROM mv_base_a
a, (SELECT i, COUNT(*) FROM mv_base_b GROUP BY i) b WHERE a.i = b.i;
         </programlisting>
        </para>
        </listitem>
      </itemizedlist>

      Unsupported queries with this option include followings:

      <itemizedlist>
       <listitem>
        <para>
         Aggregations other than built-in count, sum, avg, min and max.
        </para>
        </listitem>
       <listitem>
        <para>
         Aggregations with HAVING clause.
        </para>
        </listitem>
       <listitem>
        <para>
         CTE, WINDOW, LIMIT and OFFSET clause.
        </para>
       </listitem>
      </itemizedlist>

      Other restrictions include:
      <itemizedlist>

       <listitem>
        <para>
         IMMVs must be based on simple base tables. Views or materialized views
         are not allowed to create IMMV on them.
        </para>
       </listitem>

       <listitem>
        <para>
         When TRUNCATE command is executed on a base table, nothing occurs and
         this is not applied to the materialized view.
        </para>
       </listitem>

       <listitem>
        <para>
         IMMV including system columns is not supported.
         <programlisting>
CREATE INCREMENTAL MATERIALIZED VIEW  mv_ivm02 AS SELECT i,j FROM mv_base_a WHERE xmin = '610';
ERROR:  system column is not supported with IVM
         </programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
         IMMV including non-immutable functions is not supported.
         <programlisting>
CREATE INCREMENTAL MATERIALIZED VIEW  mv_ivm12 AS SELECT i,j FROM mv_base_a WHERE i = random()::int;
ERROR:  functions in IMMV must be marked IMMUTABLE
         </programlisting>
        </para>
        </listitem>

       <listitem>
        <para>
         IMMVs including expressions which contains aggregates in it
        </para>
       </listitem>

       <listitem>
        <para>
         IMMVs not supported by logical replication.
        </para>
       </listitem>

      </itemizedlist>

     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>IF NOT EXISTS</literal></term>
    <listitem>
     <para>
      Do not throw an error if a materialized view with the same name already
      exists. A notice is issued in this case.  Note that there is no guarantee
      that the existing materialized view is anything like the one that would
      have been created.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable>table_name</replaceable></term>
    <listitem>
     <para>
      The name (optionally schema-qualified) of the materialized view to be
      created.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable>column_name</replaceable></term>
    <listitem>
     <para>
      The name of a column in the new materialized view.  If column names are
      not provided, they are taken from the output column names of the query.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>USING <replaceable class="parameter">method</replaceable></literal></term>
    <listitem>
     <para>
      This optional clause specifies the table access method to use to store
      the contents for the new materialized view; the method needs be an
      access method of type <literal>TABLE</literal>. See <xref
      linkend="tableam"/> for more information.  If this option is not
      specified, the default table access method is chosen for the new
      materialized view. See <xref linkend="guc-default-table-access-method"/>
      for more information.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] )</literal></term>
    <listitem>
     <para>
      This clause specifies optional storage parameters for the new
      materialized view; see
      <xref linkend="sql-createtable-storage-parameters"/> in the
      <xref linkend="sql-createtable"/> documentation for more
      information.  All parameters supported for <literal>CREATE
      TABLE</literal> are also supported for <literal>CREATE MATERIALIZED
      VIEW</literal>.
      See <xref linkend="sql-createtable"/> for more information.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TABLESPACE <replaceable class="parameter">tablespace_name</replaceable></literal></term>
    <listitem>
     <para>
      The <replaceable class="parameter">tablespace_name</replaceable> is the name
      of the tablespace in which the new materialized view is to be created.
      If not specified, <xref linkend="guc-default-tablespace"/> is consulted.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable>query</replaceable></term>
    <listitem>
     <para>
      A <xref linkend="sql-select"/>, <link linkend="sql-table">TABLE</link>,
      or <xref linkend="sql-values"/> command.  This query will run within a
      security-restricted operation; in particular, calls to functions that
      themselves create temporary tables will fail.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH [ NO ] DATA</literal></term>
    <listitem>
     <para>
      This clause specifies whether or not the materialized view should be
      populated at creation time.  If not, the materialized view will be
      flagged as unscannable and cannot be queried until <command>REFRESH
      MATERIALIZED VIEW</command> is used.  Also, if the view is IMMV,
      triggers for maintaining the view are not created.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
 </refsect1>

 <refsect1>
  <title>Compatibility</title>

  <para>
   <command>CREATE MATERIALIZED VIEW</command> is a
   <productname>PostgreSQL</productname> extension.
  </para>
 </refsect1>

 <refsect1>
  <title>See Also</title>

  <simplelist type="inline">
   <member><xref linkend="sql-altermaterializedview"/></member>
   <member><xref linkend="sql-createtableas"/></member>
   <member><xref linkend="sql-createview"/></member>
   <member><xref linkend="sql-dropmaterializedview"/></member>
   <member><xref linkend="sql-refreshmaterializedview"/></member>
  </simplelist>
 </refsect1>

</refentry>
